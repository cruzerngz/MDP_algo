1 1 90
5 5 270 10
5 13 180 20
12 9 0 30
15 15 270 14
15 4 90 15
1 19 0 12

[\fc1;, \fmf40;, \fc15;, CAP,10,5,2,90, \fc12;, \fmf20;, \fc4;, \fmf100;, \fc4;, CAP,20,2,13,0, \fc15;, \fmf50;, \fc9;, CAP,12,4,18,180, \fc12;, \fmf20;, \fc12;, \fmf20;, \fc4;, \fmf20;, \fc12;, \fmf70;, \fc12;, CAP,14,15,12,90, \fc12;, \fmf30;, \fc0;, CAP,30,15,9,180, \fc12;, \fmf20;, CAP,15,15,7,270]


String turn = (String) robotInstructions.get(i + 1);
                String turnAmt = turn.substring(4);
                String refine = "";
                switch (turnAmt) {
                    case "0":
                        refine = "\\ftr0;";
                        break;
                    case "1":
                        refine = "\\ftr22;";
                        break;
                    case "2":
                        refine = "\\ftr22;";
                        break;
                    case "3":
                        refine = "\\ftr22;";
                        break;
                    case "4":
                        refine = "\\ftr22;";
                        break;
                    case "5":
                        refine = "\\ftr22;";
                        break;
                    case "6":
                        refine = "\\ftr22;";
                        break;
                    case "7":
                        refine = "\\ftr22;";
                        break;
                    case "8":
                        refine = "\\ftr22;";
                        break;
                    case "9":
                        refine = "\\ftr22;";
                        break;
                    case "10":
                        refine = "\\ftr22;";
                        break;
                    case "11":
                        refine = "\\ftr22;";
                        break;
                    case "12":
                        refine = "\\ftr22;";
                        break;
                    case "13":
                        refine = "\\ftr22;";
                        break;
                    case "14":
                        refine = "\\ftr22;";
                        break;
                    case "15":
                        refine = "\\ftr22;";
                        break;
                    default:
                }





public static Object[] psuedoDubins2(String configFile) {

        // convert configfile into arena
        Arena arena = SetupArena.setupArena(configFile);

        // obtain visiting order
        Object[][] visitingOrder = Prim.prim(arena);

        // output
        ArrayList<Object[]> verbosePath = new ArrayList<Object[]>();
        ArrayList<Object> robotInstructions = new ArrayList<Object>();

        // for each item in visiting order
        for (int step = 0; step < visitingOrder.length - 1; step++) {
            double sx = ((Number) visitingOrder[step][0]).doubleValue();
            double sy = ((Number) visitingOrder[step][1]).doubleValue();
            double syaw = ((Number) visitingOrder[step][2]).doubleValue() * (Math.PI / 180);
            int sDeg = ((Number) visitingOrder[step][2]).intValue();
            double ex = ((Number) visitingOrder[step + 1][0]).doubleValue();
            double ey = ((Number) visitingOrder[step + 1][1]).doubleValue();
            int eDeg = ((Number) visitingOrder[step + 1][2]).intValue();
            double eyaw = ((Number) visitingOrder[step + 1][2]).doubleValue() * (Math.PI / 180);
            int id = ((Number) visitingOrder[step + 1][3]).intValue();

            ///// psuedo dubins /////
            boolean gotClash = false;
            double opp = ex - sx;
            double adj = ey - sy;
            double startDirection = syaw;
            double hyp = 0;
            Object[][] tempDP = DubinsPathDriver.dubinsPathGrid(sx, sy, startDirection, ex, ey, startDirection, 1);
            if (opp != 0 & adj != 0) {
                hyp = Math.sqrt(Math.pow(opp, 2) + Math.pow(adj, 2));
                double theta = Math.abs(Math.toDegrees(Math.atan2(ex - sx, ey - sy))); // base angle
                startDirection = (ex > sx & ey > sy) ? theta
                        : (ex < sx & ey > sy) ? 180 - theta : (ex < sx & ey < sy) ? 270 - theta : 360 - theta;
                tempDP = DubinsPathDriver.dubinsPathGrid(sx, sy, startDirection, ex, ey, startDirection, 1);
                // clash checking
                for (Object[] dpStep : tempDP) {
                    if (arena.entityClash(
                            new int[] { ((Number) dpStep[0]).intValue(), ((Number) dpStep[1]).intValue() })) {
                        gotClash = true;
                        break;
                    }

                }
            } else {
                gotClash = true;
            }

            if (gotClash == false) {

                verbosePath.add(new Object[] { (int) sx, (int) sy, sDeg, " " });
                verbosePath.add(new Object[] { (int) sx, (int) sy, startDirection, " " });
                for (Object[] dpStep : tempDP) {
                    verbosePath.add(new Object[] { dpStep[0], dpStep[1], dpStep[2], " " });
                }

                robotInstructions.add(stmConvert(sDeg, startDirection, "OTS"));
                robotInstructions.add(stmConvert("S", (int) hyp));
                robotInstructions.add(stmConvert(startDirection, eDeg, "OTS"));
                robotInstructions.add(String.format("CAP,%s,%s,%s,%s", id, (int) ex, (int) ey, eDeg));
            } else {
                // generate a manhattan path that is less efficient but guaranteed to be safe
                int localInitDeg = ((Number) visitingOrder[step][2]).intValue();
                Manhattan man2 = new Manhattan();
                Object[][] pathing = man2.manhattan(arena, (int) Math.round(sx), (int) Math.round(sy),
                        (int) Math.round(ex), (int) Math.round(ey));
                ArrayList<Object> tempRobotInst = new ArrayList<Object>();

                boolean previousTurn = false;
                int forwardCounter = 0;
                for (int i = 0; i < pathing.length - LOOKAHEAD; i++) {
                    int startX = (int) pathing[i][0];
                    int startY = (int) pathing[i][1];
                    int endX = (int) pathing[i + LOOKAHEAD][0];
                    int endY = (int) pathing[i + LOOKAHEAD][1];
                    String output = "";

                    /*
                    if ((pathing[i][0] == pathing[i + 1][0] & pathing[i + 3][1] == pathing[i + 4][1])
                            | (pathing[i][1] == pathing[i + 1][1] & pathing[i + 3][0] == pathing[i + 4][0])) { */

                    if (endX > startX & endY > startY) {
                        // ends up north east
                        if (localInitDeg == 0) {
                            output = "\\ftlf90;";
                            globalInitDeg = 90;
                        } else if (localInitDeg == 90) {
                            output = "\\ftrf90;";
                            globalInitDeg = 0;
                        }
                    } else if (endX > startX & endY < startY) {
                        // southeast
                        if (localInitDeg == 0) {
                            output = "\\ftrf90;";
                            globalInitDeg = 270;
                        } else if (localInitDeg == 270) {
                            output = "\\ftlf90;";
                            globalInitDeg = 0;
                        }

                    } else if (endX < startX & endY > startY) {
                        // northw
                        if (localInitDeg == 180) {
                            output = "\\ftrf90;";
                            globalInitDeg = 90;
                        } else if (localInitDeg == 90) {
                            output = "\\ftlf90;";
                            globalInitDeg = 180;
                        }

                    } else if (endX < startX & endY < startY) {
                        // move sw
                        if (localInitDeg == 180) {
                            output = "\\ftlf90;";
                            globalInitDeg = 270;
                        } else if (localInitDeg == 270) {
                            output = "\\ftrf90;";
                            globalInitDeg = 180;
                        }
                    }

                    if (output == "") {
                        if (previousTurn) {
                            previousTurn = false;
                        } else {
                            forwardCounter++;
                        }

                    } else if (output == "" & i == pathing.length - LOOKAHEAD) {
                        String toAdd = "\\fmf";
                        robotInstructions.add(toAdd);
                    } else {
                        String forward = "\\fmf" + forwardCounter + ";";
                        forwardCounter = 0;
                        robotInstructions.add(forward);
                        robotInstructions.add(output);
                        previousTurn = true;
                    }

                    localInitDeg = globalInitDeg;
                }

                boolean prevIsStr = false;
                int strCount = 0;
                for (Object inst : tempRobotInst) {
                    if (inst == "\\fmf10;" & prevIsStr == false) {
                        strCount++;
                        prevIsStr = true;
                    } else if (inst == "\\fmf10;" & prevIsStr == true) {
                        strCount++;
                    } else if (inst != "\\fmf10;" & prevIsStr == true) {
                        prevIsStr = false;
                        String toAdd = "\\fmf" + strCount * 10 + ";";
                        strCount = 0;
                        robotInstructions.add(toAdd);
                        robotInstructions.add(inst);
                    } else {
                        robotInstructions.add(inst);
                    }
                }
            }

        }
        // 

        Object[][] verboseOutput = new Object[verbosePath.size()][4];
        verboseOutput = verbosePath.toArray(verboseOutput);
        globalVerbosePath = verboseOutput;

        Object[] output2 = new Object[robotInstructions.size()];
        output2 = robotInstructions.toArray(output2);

        return output2;
    }
